# -*- coding: utf-8 -*-
"""202210688안혁진 계산물리학 메트로폴리스 개선.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H2zfrkSJXjNTy-3ln6DY-Wr6GfueiT3o
"""

import numpy as np

# 함수 정의: N x N 크기의 랜덤 이진 행렬 생성
def L(N):
    return np.random.choice([-1, 1], size=(N, N))

N = 5  # 행렬의 크기
matrix_u = L(N)  # N x N 크기의 랜덤 이진 행렬 생성

print(matrix_u)

import numpy as np

N = 5  # 행렬의 크기
matrix_u = np.random.choice([-1, 1], size=(N, N))  # N x N 크기의 랜덤 이진 행렬 생성

# matrix_u를 복사하여 matrix_v 생성
matrix_v = np.copy(matrix_u)

# 임의의 위치 (i, j) 선택
i, j = np.random.randint(0, N), np.random.randint(0, N)

# 선택된 위치 (i, j)의 값 반전 (-1을 곱함)
matrix_v[i, j] *= -1

print("Original Matrix (matrix_u):")
print(matrix_u)
print("\nModified Matrix (matrix_v):")
print(matrix_v)

def neighber(number,matrix, N):
    i, j = divmod(number, N)
    self = matrix[i][j]
    result = []

    result.append(matrix[(i-1) % N, j])  # 위쪽
    result.append(matrix[(i+1) % N, j])  # 아래쪽
    result.append(matrix[i, (j-1) % N])  # 왼쪽
    result.append(matrix[i, (j+1) % N])  # 오른쪽


    return result , self

def calculate_total_E(matrix, N):
    total_E = 0
    for i in range(N * N):
        neighbors, self = neighbor(i, matrix, N)  # 이웃들과 현재 위치의 값을 가져옴
        for neighbor_v in neighbors:
            total_E += -neighbor_v * self  # 각 이웃과 현재 위치의 상호작용 에너지 합을 계산

    return total_E / 2  # 계산된 총 상호작용 에너지를 2로 나누어 반환

def delta_E(i,j,matrix):

    self = matrix[i][j]
    result = []

    result.append(matrix[(i-1) % N, j])  # 위쪽
    result.append(matrix[(i+1) % N, j])  # 아래쪽
    result.append(matrix[i, (j-1) % N])  # 왼쪽
    result.append(matrix[i, (j+1) % N])  # 오른쪽


    return 2*self*sum(result)

import numpy as np
import matplotlib.pyplot as plt

N = 5  # 행렬의 크기
beta = 1  # 역온도
T = 1000  # 시뮬레이션 반복 횟수
elist = []  # 에너지 리스트
spin_total = []  # 전체 스핀 모멘트 리스트

# 역온도에 따른 exponential 값 계산
exp4Beta = np.exp(-4 * beta)
exp8Beta = np.exp(-8 * beta)
print("exp(-4*beta):", exp4Beta)
print("exp(-8*beta):", exp8Beta)

# 초기 랜덤 이진 행렬 생성
def L(N):
    return np.random.choice([-1, 1], size=(N, N))

# 이웃과의 상호작용 에너지 계산 함수 정의
def calculate_total_E(matrix, N):
    total_E = 0
    for i in range(N * N):
        neighbors, self = neighbor(i, matrix, N)
        for neighbor_v in neighbors:
            total_E += -neighbor_v * self
    return total_E / 2

# 이웃 값을 가져오는 함수 정의
def neighbor(number, matrix, N):
    i, j = divmod(number, N)
    self = matrix[i][j]
    result = []
    result.append(matrix[(i - 1) % N, j])  # 위쪽
    result.append(matrix[(i + 1) % N, j])  # 아래쪽
    result.append(matrix[i, (j - 1) % N])  # 왼쪽
    result.append(matrix[i, (j + 1) % N])  # 오른쪽
    return result, self

# 에너지 차이를 계산하는 함수 정의
def delta_E(i, j, matrix):
    N = len(matrix)
    neighbors, self = neighbor(i * N + j, matrix, N)
    delta_E = 2 * self * sum(neighbors)
    return delta_E

# 초기 행렬 생성
matrix_u = L(N)

# Metropolis 알고리즘을 이용한 시뮬레이션
for i in range(T):
    matrix_v = np.copy(matrix_u)
    i, j = np.random.randint(0, N), np.random.randint(0, N)
    matrix_v[i, j] *= -1  # 임의의 위치의 값을 반전시킴
    E_u = calculate_total_E(matrix_u, N)  # 현재 행렬의 에너지 계산
    E_v = E_u + delta_E(i, j, matrix_u)  # 반전된 행렬의 에너지 계산

    # Metropolis 알고리즘 적용
    if delta_E(i, j, matrix_u) <= 0:
        matrix_u = np.copy(matrix_v)  # 에너지가 낮아지면 항상 반전된 행렬을 수락
        elist.append(E_v)  # 에너지 리스트에 추가
        spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가
    else:
        pb = exp4Beta if delta_E(i, j, matrix_u) == 4 else exp8Beta
        if np.random.rand() < pb:
            matrix_u = np.copy(matrix_v)  # 확률적으로 반전된 행렬을 수락
            elist.append(E_v)  # 에너지 리스트에 추가
            spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가
        else:
            elist.append(E_u)  # 반전되지 않은 경우 현재 에너지를 유지
            spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가

# 결과 시각화
plt.plot(elist)
plt.xlabel('Iteration')
plt.ylabel('Energy')
plt.title('Energy vs Iteration')
plt.show()

plt.plot(spin_total)
plt.xlabel('Iteration')
plt.ylabel('Total Spin Moment')
plt.title('Total Spin Moment vs Iteration')
plt.show()

# 최종 결과 출력
print("Total Spin Moment:")
print(spin_total)
print("\nEnergy:")
print(elist)

import numpy as np
import matplotlib.pyplot as plt

N = 5  # 행렬의 크기
T = 1000  # 시뮬레이션 반복 횟수

# 초기 랜덤 이진 행렬 생성
def L(N):
    return np.random.choice([-1, 1], size=(N, N))

# 이웃과의 상호작용 에너지 계산 함수 정의
def calculate_total_E(matrix, N):
    total_E = 0
    for i in range(N * N):
        neighbors, self = neighbor(i, matrix, N)
        for neighbor_v in neighbors:
            total_E += -neighbor_v * self
    return total_E / 2

# 이웃 값을 가져오는 함수 정의
def neighbor(number, matrix, N):
    i, j = divmod(number, N)
    self = matrix[i][j]
    result = []
    result.append(matrix[(i - 1) % N, j])  # 위쪽
    result.append(matrix[(i + 1) % N, j])  # 아래쪽
    result.append(matrix[i, (j - 1) % N])  # 왼쪽
    result.append(matrix[i, (j + 1) % N])  # 오른쪽
    return result, self

# 에너지 차이를 계산하는 함수 정의
def delta_E(i, j, matrix):
    N = len(matrix)
    neighbors, self = neighbor(i * N + j, matrix, N)
    delta_E = 2 * self * sum(neighbors)
    return delta_E

# 메트로폴리스 알고리즘을 이용한 시뮬레이션 함수 정의
def simulate(beta):
    elist = []  # 에너지 리스트
    spin_total = []  # 전체 스핀 모멘트 리스트
    exp4Beta = np.exp(-4 * beta)
    exp8Beta = np.exp(-8 * beta)

    matrix_u = L(N)  # 초기 랜덤 이진 행렬 생성
    for _ in range(T):
        matrix_v = np.copy(matrix_u)
        i, j = np.random.randint(0, N), np.random.randint(0, N)
        matrix_v[i, j] *= -1  # 임의의 위치의 값을 반전시킴
        E_u = calculate_total_E(matrix_u, N)  # 현재 행렬의 에너지 계산
        E_v = E_u + delta_E(i, j, matrix_u)  # 반전된 행렬의 에너지 계산

        # Metropolis 알고리즘 적용
        if delta_E(i, j, matrix_u) <= 0:
            matrix_u = np.copy(matrix_v)  # 에너지가 낮아지면 항상 반전된 행렬을 수락
            elist.append(E_v)  # 에너지 리스트에 추가
            spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가
        else:
            pb = exp4Beta if delta_E(i, j, matrix_u) == 4 else exp8Beta
            if np.random.rand() < pb:
                matrix_u = np.copy(matrix_v)  # 확률적으로 반전된 행렬을 수락
                elist.append(E_v)  # 에너지 리스트에 추가
                spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가
            else:
                elist.append(E_u)  # 반전되지 않은 경우 현재 에너지를 유지
                spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가

    return elist, spin_total

beta_values = np.linspace(0.1, 1, 10)  # 베타 값을 0.1부터 1까지 10개 구간으로 나눔

energy_results = []
spin_results = []

# 각 베타 값에 대해 시뮬레이션 실행 및 결과 저장
for beta in beta_values:
    elist, spin_total = simulate(beta)
    energy_results.append(np.mean(elist))  # 에너지의 평균
    spin_results.append(np.mean(np.abs(spin_total)))  # 스핀 평균의 절대값의 평균

# 결과 시각화
plt.figure(figsize=(12, 6))

# 에너지 그래프
plt.subplot(1, 2, 1)
plt.plot(beta_values, energy_results, marker='o', linestyle='-', color='blue')
plt.xlabel('Beta')
plt.ylabel('Average Energy')
plt.title('Average Energy vs Beta')

# 스핀 평균의 절대값 그래프
plt.subplot(1, 2, 2)
plt.plot(beta_values, spin_results, marker='o', linestyle='-', color='green')
plt.xlabel('Beta')
plt.ylabel('Average Absolute Spin')
plt.title('Average Absolute Spin vs Beta')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

N = 5  # 행렬의 크기
T = 10000  # 시뮬레이션 반복 횟수
NUM_SIMULATIONS = 10  # 각 베타 값에 대해 시뮬레이션을 반복할 횟수

# 초기 랜덤 이진 행렬 생성
def L(N):
    return np.random.choice([-1, 1], size=(N, N))

# 이웃과의 상호작용 에너지 계산 함수 정의
def calculate_total_E(matrix, N):
    total_E = 0
    for i in range(N * N):
        neighbors, self = neighbor(i, matrix, N)
        for neighbor_v in neighbors:
            total_E += -neighbor_v * self
    return total_E / 2

# 이웃 값을 가져오는 함수 정의
def neighbor(number, matrix, N):
    i, j = divmod(number, N)
    self = matrix[i][j]
    result = []
    result.append(matrix[(i - 1) % N, j])  # 위쪽
    result.append(matrix[(i + 1) % N, j])  # 아래쪽
    result.append(matrix[i, (j - 1) % N])  # 왼쪽
    result.append(matrix[i, (j + 1) % N])  # 오른쪽
    return result, self

# 에너지 차이를 계산하는 함수 정의
def delta_E(i, j, matrix):
    N = len(matrix)
    neighbors, self = neighbor(i * N + j, matrix, N)
    delta_E = 2 * self * sum(neighbors)
    return delta_E

# 메트로폴리스 알고리즘을 이용한 시뮬레이션 함수 정의
def simulate(beta):
    elist = []  # 에너지 리스트
    spin_total = []  # 전체 스핀 모멘트 리스트
    exp4Beta = np.exp(-4 * beta)
    exp8Beta = np.exp(-8 * beta)

    for _ in range(NUM_SIMULATIONS):
        matrix_u = L(N)  # 초기 랜덤 이진 행렬 생성
        for _ in range(T):
            matrix_v = np.copy(matrix_u)
            i, j = np.random.randint(0, N), np.random.randint(0, N)
            matrix_v[i, j] *= -1  # 임의의 위치의 값을 반전시킴
            E_u = calculate_total_E(matrix_u, N)  # 현재 행렬의 에너지 계산
            E_v = E_u + delta_E(i, j, matrix_u)  # 반전된 행렬의 에너지 계산

            # Metropolis 알고리즘 적용
            if delta_E(i, j, matrix_u) <= 0:
                matrix_u = np.copy(matrix_v)  # 에너지가 낮아지면 항상 반전된 행렬을 수락
                elist.append(E_v)  # 에너지 리스트에 추가
                spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가
            else:
                pb = exp4Beta if delta_E(i, j, matrix_u) == 4 else exp8Beta
                if np.random.rand() < pb:
                    matrix_u = np.copy(matrix_v)  # 확률적으로 반전된 행렬을 수락
                    elist.append(E_v)  # 에너지 리스트에 추가
                    spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가
                else:
                    elist.append(E_u)  # 반전되지 않은 경우 현재 에너지를 유지
                    spin_total.append(np.sum(matrix_u) / (N * N))  # 전체 스핀 모멘트 리스트에 추가

    return np.mean(elist), np.mean(np.abs(spin_total))  # 평균 에너지와 평균 절댓값 스핀 모멘트 반환

beta_values = np.linspace(0.1, 1, 10)  # 베타 값을 0.1부터 1까지 10개 구간으로 나눔

energy_results = []
spin_results = []

# 각 베타 값에 대해 10번 시뮬레이션 실행 및 결과 저장
for beta in beta_values:
    avg_energy = 0
    avg_abs_spin = 0
    for _ in range(NUM_SIMULATIONS):
        avg_e, avg_abs_s = simulate(beta)
        avg_energy += avg_e
        avg_abs_spin += avg_abs_s
    avg_energy /= NUM_SIMULATIONS
    avg_abs_spin /= NUM_SIMULATIONS
    energy_results.append(avg_energy)
    spin_results.append(avg_abs_spin)

# 결과 시각화
plt.figure(figsize=(12, 6))

# 에너지 그래프
plt.subplot(1, 2, 1)
plt.plot(beta_values, energy_results, marker='o', linestyle='-', color='blue')
plt.xlabel('Beta')
plt.ylabel('Average Energy')
plt.title('Average Energy vs Beta')

# 스핀 평균의 절대값 그래프
plt.subplot(1, 2, 2)
plt.plot(beta_values, spin_results, marker='o', linestyle='-', color='green')
plt.xlabel('Beta')
plt.ylabel('Average Absolute Spin')
plt.title('Average Absolute Spin vs Beta')

plt.tight_layout()
plt.show()